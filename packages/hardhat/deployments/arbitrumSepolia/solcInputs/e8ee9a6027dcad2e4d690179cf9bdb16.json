{
  "language": "Solidity",
  "sources": {
    "contracts/Payroll.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Payroll {\n\n    struct PayrollData {\n        address employer;\n        uint256 paymentDay; // Day of month (1-31)\n        uint256 months; // Number of months the payroll will run\n        uint256 startMonth; // Start month (1-12)\n        uint256 startYear; // Start year (e.g., 2024)\n        uint256 totalAmount; // Total amount for all months\n        uint256 createdAt;\n        bool active;\n    }\n\n    struct EmployeePayment {\n        address employee;\n        uint256 monthlyAmount; // Amount per month\n        uint256 totalMonths; // Total number of months\n    }\n\n    // Mapping from payroll ID to payroll data\n    mapping(uint256 => PayrollData) public payrolls;\n    \n    // Mapping from payroll ID to employee address to payment data\n    mapping(uint256 => mapping(address => EmployeePayment)) public employeePayments;\n    \n    // Mapping from payroll ID to array of employee addresses\n    mapping(uint256 => address[]) public payrollEmployees;\n    \n    // Mapping from payroll ID => employee address => month => year => claimed\n    // Tracks if a specific month/year has been claimed\n    mapping(uint256 => mapping(address => mapping(uint256 => mapping(uint256 => bool)))) public monthlyClaims;\n    \n    // Counter for payroll IDs\n    uint256 public payrollCounter;\n\n    // Events\n    event PayrollCreated(\n        uint256 indexed payrollId,\n        address indexed employer,\n        uint256 paymentDay,\n        uint256 months,\n        uint256 totalAmount,\n        address[] employees\n    );\n    \n    event PayrollClaimed(\n        uint256 indexed payrollId,\n        address indexed employee,\n        uint256 month,\n        uint256 year,\n        uint256 amount\n    );\n    \n    event FundsDeposited(\n        uint256 indexed payrollId,\n        address indexed employer,\n        uint256 amount\n    );\n\n    constructor() {}\n\n    /**\n     * @dev Setup a new payroll\n     * @param paymentDay Day of month when payroll becomes claimable (1-31)\n     * @param months Number of months the payroll will run\n     * @param employees Array of employee addresses\n     * @param monthlyAmounts Array of monthly amounts for each employee (in wei)\n     */\n    function setupPayroll(\n        uint256 paymentDay,\n        uint256 months,\n        address[] calldata employees,\n        uint256[] calldata monthlyAmounts\n    ) external returns (uint256) {\n        require(paymentDay >= 1 && paymentDay <= 31, \"Invalid payment day\");\n        require(months > 0 && months <= 60, \"Invalid months (1-60)\");\n        require(employees.length == monthlyAmounts.length, \"Arrays length mismatch\");\n        require(employees.length > 0, \"No employees provided\");\n\n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < monthlyAmounts.length; i++) {\n            require(employees[i] != address(0), \"Invalid employee address\");\n            require(monthlyAmounts[i] > 0, \"Amount must be greater than 0\");\n            totalAmount += monthlyAmounts[i] * months; // Total for all months\n        }\n\n        uint256 payrollId = payrollCounter++;\n        \n        (uint256 startMonth, uint256 startYear) = getCurrentMonthYear();\n        \n        payrolls[payrollId] = PayrollData({\n            employer: msg.sender,\n            paymentDay: paymentDay,\n            months: months,\n            startMonth: startMonth,\n            startYear: startYear,\n            totalAmount: totalAmount,\n            createdAt: block.timestamp,\n            active: true\n        });\n\n        // Store employee payments\n        for (uint256 i = 0; i < employees.length; i++) {\n            employeePayments[payrollId][employees[i]] = EmployeePayment({\n                employee: employees[i],\n                monthlyAmount: monthlyAmounts[i],\n                totalMonths: months\n            });\n            payrollEmployees[payrollId].push(employees[i]);\n        }\n\n        emit PayrollCreated(payrollId, msg.sender, paymentDay, months, totalAmount, employees);\n\n        return payrollId;\n    }\n\n    /**\n     * @dev Deposit funds for a payroll\n     * @param payrollId The payroll ID\n     * @notice The amount sent must match the totalAmount for the payroll\n     */\n    function depositFunds(uint256 payrollId) external payable {\n        PayrollData storage payroll = payrolls[payrollId];\n        require(payroll.employer == msg.sender, \"Not the employer\");\n        require(payroll.active, \"Payroll not active\");\n        require(msg.value == payroll.totalAmount, \"Amount mismatch\");\n\n        emit FundsDeposited(payrollId, msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Check if a specific month is claimable\n     * @param payrollId The payroll ID\n     * @param month The month to check (1-12)\n     * @param year The year to check\n     */\n    function isMonthClaimable(uint256 payrollId, uint256 month, uint256 year) public view returns (bool) {\n        PayrollData memory payroll = payrolls[payrollId];\n        if (!payroll.active) return false;\n\n        // Check if the month is within the payroll period\n        uint256 monthsElapsed = getMonthsElapsed(payroll.startMonth, payroll.startYear, month, year);\n        if (monthsElapsed >= payroll.months) return false;\n        if (month < payroll.startMonth && year == payroll.startYear) return false;\n\n        // Get current day of month\n        uint256 currentDay = getDayOfMonth(block.timestamp);\n        (uint256 currentMonth, uint256 currentYear) = getCurrentMonthYear();\n        \n        // Can claim if:\n        // 1. The payment day has passed for this month/year, OR\n        // 2. It's a previous month/year that hasn't been claimed yet\n        if (year < currentYear || (year == currentYear && month < currentMonth)) {\n            // Previous month - can claim if not already claimed\n            return !monthlyClaims[payrollId][msg.sender][month][year];\n        } else if (year == currentYear && month == currentMonth) {\n            // Current month - can claim if payment day has passed\n            return currentDay >= payroll.paymentDay && !monthlyClaims[payrollId][msg.sender][month][year];\n        }\n        \n        return false;\n    }\n\n    /**\n     * @dev Claim payroll for a specific month\n     * @param payrollId The payroll ID\n     * @param month The month to claim (1-12)\n     * @param year The year to claim\n     */\n    function claimPayroll(uint256 payrollId, uint256 month, uint256 year) external {\n        require(isMonthClaimable(payrollId, month, year), \"Month not claimable\");\n\n        EmployeePayment memory payment = employeePayments[payrollId][msg.sender];\n        require(payment.employee == msg.sender, \"Not eligible for this payroll\");\n        require(payment.monthlyAmount > 0, \"No amount to claim\");\n        require(!monthlyClaims[payrollId][msg.sender][month][year], \"Already claimed this month\");\n\n        // Check that contract has sufficient balance\n        require(address(this).balance >= payment.monthlyAmount, \"Insufficient contract balance\");\n\n        // Mark as claimed BEFORE external call (checks-effects-interactions pattern)\n        monthlyClaims[payrollId][msg.sender][month][year] = true;\n\n        // Transfer the monthly amount in native ETH\n        (bool success, ) = payable(msg.sender).call{value: payment.monthlyAmount}(\"\");\n        require(success, \"ETH transfer failed\");\n\n        emit PayrollClaimed(payrollId, msg.sender, month, year, payment.monthlyAmount);\n    }\n\n    /**\n     * @dev Check claimable amount for an employee for a specific month\n     * @param payrollId The payroll ID\n     * @param employee The employee address\n     * @param month The month to check (1-12)\n     * @param year The year to check\n     */\n    function checkBalance(uint256 payrollId, address employee, uint256 month, uint256 year) external view returns (uint256) {\n        EmployeePayment memory payment = employeePayments[payrollId][employee];\n        if (payment.monthlyAmount == 0) return 0;\n        if (!isMonthClaimable(payrollId, month, year)) return 0;\n        if (monthlyClaims[payrollId][employee][month][year]) return 0;\n        return payment.monthlyAmount;\n    }\n\n    /**\n     * @dev Get all unclaimed months for an employee\n     * @param payrollId The payroll ID\n     * @param employee The employee address\n     */\n    function getUnclaimedMonths(uint256 payrollId, address employee) external view returns (uint256[] memory, uint256[] memory) {\n        PayrollData memory payroll = payrolls[payrollId];\n        EmployeePayment memory payment = employeePayments[payrollId][employee];\n        \n        if (payment.monthlyAmount == 0) {\n            return (new uint256[](0), new uint256[](0));\n        }\n\n        uint256[] memory unclaimedMonths = new uint256[](payroll.months);\n        uint256[] memory unclaimedYears = new uint256[](payroll.months);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < payroll.months; i++) {\n            uint256 month = payroll.startMonth;\n            uint256 year = payroll.startYear;\n            \n            // Calculate the month/year for this iteration\n            month += i;\n            while (month > 12) {\n                month -= 12;\n                year += 1;\n            }\n            \n            // Check if this month is claimable and not claimed\n            if (isMonthClaimableForEmployee(payrollId, employee, month, year, payroll)) {\n                unclaimedMonths[count] = month;\n                unclaimedYears[count] = year;\n                count++;\n            }\n        }\n\n        // Resize arrays to actual count\n        uint256[] memory resultMonths = new uint256[](count);\n        uint256[] memory resultYears = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            resultMonths[i] = unclaimedMonths[i];\n            resultYears[i] = unclaimedYears[i];\n        }\n\n        return (resultMonths, resultYears);\n    }\n\n    /**\n     * @dev Internal helper to check if month is claimable for a specific employee\n     */\n    function isMonthClaimableForEmployee(\n        uint256 payrollId,\n        address employee,\n        uint256 month,\n        uint256 year,\n        PayrollData memory payroll\n    ) internal view returns (bool) {\n        if (!payroll.active) return false;\n\n        // Check if already claimed\n        if (monthlyClaims[payrollId][employee][month][year]) return false;\n\n        // Check if within payroll period\n        uint256 monthsElapsed = getMonthsElapsed(payroll.startMonth, payroll.startYear, month, year);\n        if (monthsElapsed >= payroll.months) return false;\n\n        // Get current day of month\n        uint256 currentDay = getDayOfMonth(block.timestamp);\n        (uint256 currentMonth, uint256 currentYear) = getCurrentMonthYear();\n        \n        // Can claim if:\n        // 1. Previous month/year that hasn't been claimed\n        // 2. Current month/year and payment day has passed\n        if (year < currentYear || (year == currentYear && month < currentMonth)) {\n            return true; // Previous month - can claim\n        } else if (year == currentYear && month == currentMonth) {\n            return currentDay >= payroll.paymentDay; // Current month - check payment day\n        }\n        \n        return false;\n    }\n\n    /**\n     * @dev Get months elapsed between two month/year pairs\n     */\n    function getMonthsElapsed(\n        uint256 startMonth,\n        uint256 startYear,\n        uint256 endMonth,\n        uint256 endYear\n    ) internal pure returns (uint256) {\n        if (endYear < startYear) return 0;\n        if (endYear == startYear && endMonth < startMonth) return 0;\n        \n        uint256 yearsDiff = endYear - startYear;\n        uint256 monthsDiff = endMonth >= startMonth \n            ? endMonth - startMonth \n            : (12 - startMonth) + endMonth;\n        \n        return (yearsDiff * 12) + monthsDiff;\n    }\n\n    /**\n     * @dev Get current month and year from timestamp\n     */\n    function getCurrentMonthYear() internal view returns (uint256 month, uint256 year) {\n        // This is a simplified implementation\n        // In production, use a proper date library or oracle\n        uint256 timestamp = block.timestamp;\n        \n        // Approximate: Jan 1, 1970 = 0\n        // Each month is approximately 2,592,000 seconds (30 days)\n        uint256 monthsSinceEpoch = timestamp / 2592000;\n        \n        year = 1970 + (monthsSinceEpoch / 12);\n        month = (monthsSinceEpoch % 12) + 1;\n        \n        if (month == 0) month = 1;\n        if (month > 12) month = 12;\n    }\n\n    /**\n     * @dev Get day of month from timestamp\n     */\n    function getDayOfMonth(uint256 timestamp) internal pure returns (uint256) {\n        // Simplified implementation\n        uint256 daysSinceEpoch = timestamp / 86400;\n        uint256 day = (daysSinceEpoch % 31) + 1;\n        if (day == 0) day = 1;\n        if (day > 31) day = 31;\n        return day;\n    }\n\n    /**\n     * @dev Get payroll data\n     */\n    function getPayroll(uint256 payrollId) external view returns (PayrollData memory) {\n        return payrolls[payrollId];\n    }\n\n    /**\n     * @dev Get employee payment data\n     */\n    function getEmployeePayment(uint256 payrollId, address employee) external view returns (EmployeePayment memory) {\n        return employeePayments[payrollId][employee];\n    }\n\n    /**\n     * @dev Get all employees for a payroll\n     */\n    function getPayrollEmployees(uint256 payrollId) external view returns (address[] memory) {\n        return payrollEmployees[payrollId];\n    }\n\n    /**\n     * @dev Check if a specific month has been claimed\n     */\n    function hasClaimedMonth(uint256 payrollId, address employee, uint256 month, uint256 year) external view returns (bool) {\n        return monthlyClaims[payrollId][employee][month][year];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}